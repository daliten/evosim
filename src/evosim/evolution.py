from evosim.population import Population
from pathlib import Path
import pandas as pd
import matplotlib.pyplot as plt
from matplotlib.lines import Line2D
import seaborn as sns
import numpy as np
from datetime import datetime


plt.rcParams["font.size"] = 18
plt.rcParams["font.family"] = 'Arial'
TIME_EPS=0.01 #this is for keeping track of all time points after dilutions


def convert_time_list(tc_time,time_conversion):
    """
    Performs time conversion of a list of times from one time unit to another.
    
    Parameters
    ----------
    tc_time : list of floats
        List of recorded time intervals.
    time_conversion : str
        Time units to/from, options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks', 'hours_to_months', 'hours_to_years'.

    Raises
    ------
    Exception
        If given time_conversion option not found among available options.

    Returns
    -------
    list of floats
        Rescaled list of recorded time intervals.

    """
    if time_conversion=='days_to_weeks':
        tc_time=np.array(tc_time)/7
    elif time_conversion=='days_to_months':
        tc_time=np.array(tc_time)/30
    elif time_conversion=='days_to_years':
        tc_time=np.array(tc_time)/365
    elif time_conversion=='hours_to_days':
        tc_time = np.array(tc_time)/24
    elif time_conversion=='hours_to_weeks':
        tc_time = np.array(tc_time)/(24*7)
    elif time_conversion=='hours_to_months':
        tc_time = np.array(tc_time)/(24*30)
    elif time_conversion=='hours_to_years':
        tc_time = np.array(tc_time)/(24*365)
    else:
        raise Exception('Time conversion option not found; refer to documentation')
            
    return tc_time



def plot_subpops_vs_time(tc,scale,time_conversion,fname):
    """
    Generates and saves a clonal evolution time course plot from a time course dataframe generated by `Simulator.evolve` call(s).
    
    Parameters
    ----------
    tc: dataframe
        Table of population distribution time course generated by a previous call to `Simulator.evolve`.
    scale : str
        Plot population levels on a linear or logarithmic scale.
    time_conversion: str
        Convert to different time units. Options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks','hours_to_months', 'hours_to_years'.
    fname : str
        Name of file to save plot to.

    Returns
    -------
    None.

    """
    plt.figure(figsize=(8,5))
    tc_time=list(tc.index)
    if time_conversion:
        tc_time = convert_time_list(tc_time,time_conversion)
    for col in tc.columns:
        plt.plot(tc_time,tc[col],label=col)
        if scale=='log':
            plt.yscale('log')
    plt.xlabel('Time')
    plt.ylabel('Number of cells')
    plt.legend(bbox_to_anchor=(1.1, 1.0),prop={'size': 16})
    plt.tight_layout()
    plt.savefig(fname)
    plt.show()
    
def shannon(p):
    """
    Computes the Shannon index $$H = -\\sum_{i=1}^N p_i\\ln p_i$$ from a list of all clonal proportions \(p\) over all \(N\) cell types.   
    """
    p=list(filter(lambda pi: pi != 0, p))
    s= np.sum([pi*np.log(pi) for pi in p])
    if s==0.:
        return s
    else:
        return -s

def simpson(p):
    """
    Computes the Simpson index $$\\lambda = \\sum_{i=1}^N p_i^2$$ from a list of all clonal proportions \(p\) over all \(N\) cell types.   
    """
    p=list(filter(lambda pi: pi != 0, p))
    return np.sum([pi**2 for pi in p])

def gini_simpson(p):
    """
    Computes the Gini-Simpson index $$1-\\lambda = 1-\\sum_{i=1}^N p_i^2$$ from a list of all clonal proportions \(p\) over all \(N\) cell types.   
    """
    p=list(filter(lambda pi: pi != 0, p))
    return 1-np.sum([pi**2 for pi in p])

def gini(p):
    """
    Computes the Gini index $$G = \\frac{\\sum_{i=1}^N \\sum_{j=1}^N |p_i-p_j|}{2N\\sum_{i=1}^N x_i}$$ from a list of all clonal proportions \(p\) over all \(N\) cell types.   
    """
    p=list(filter(lambda pi: pi != 0, p))
    numerator=0
    for pi in p:
        for pj in p:
            numerator+=abs(pi-pj)
    return numerator/(2*len(p)*np.sum(p))

def get_div_dist(dists,index):
    """
    Computes a list of diversity indices from a list of population distributions.

    Parameters
    ----------
    dists : list of lists
        List of population distributions (each distribution is a list of size equal to the number of allowable cell types).
    index: str
            Diversity index. Options are 'shannon', 'simpson', 'gini-simpson', and 'gini'. See functions `shannon`, `simpson`, `gini_simpson`, `gini`.

    Raises
    ------
    Exception
        If 'index' is not one of the allowed options.

    Returns
    -------
    list
        List of diversity indices.

    """
    if index=='shannon':
        return [shannon(np.array(dist)/sum(dist)) for dist in dists]
    elif index=='simpson':
        return [simpson(np.array(dist)/sum(dist)) for dist in dists]
    elif index=='gini-simpson':
        return [gini_simpson(np.array(dist)/sum(dist)) for dist in dists]
    elif index=='gini':
        return [gini(np.array(dist)/sum(dist)) for dist in dists]
    else:
        raise Exception('Diversity index not found; refer to documentation')
    
class Simulator:
    """
    Single-run simulation of clonal evolution. Uses an initial population distribution and demographic parameters to stochastically generate a time course of population distributions using either the extended-time leaping method (default) or Gillespie's algorithm.

    """  
    def __init__(self):
        
        Path('results').mkdir(parents=True, exist_ok=True)
        self.pop = Population()
        
        self.full_time_course = {}
        """
        Tracks the full evolution of the system (dict).
        """
        self.main_time = 0.
        """
        Time since simulation initiation.
        """
        self.folder_name = ''

        
    def initialize(self,pop_structure,**kwargs):
        """
        Initializes a single-run simulation.
        
        Parameters
        ----------
        pop_structure: dict
            Initial population distribution specified as {'Name1':Pop1,'Name2':Pop2,...,'NameN':PopN} with Pop1,...,PopN int; 'Name1',...,'NameN' str.
        method: str, optional
            Specify 'leaping' for extended-time leaping (fast for large populations) or 'SSA' for Gillespie's algorithm (slow for large populations). Default is extended-time leaping.
        leap_threshold: int, optional 
            Subpopulation threshold at which leaping sets in, if in 'leaping' mode. Defaults to 10^2.
        carrying_capacity: int, optional 
            Carrying capacity of environment. Defaults to 10^18.
        new_folder: bool, optional
            Save simulation results into a new time-stamped folder instead of default ('results') folder.
        
        Raises
        ------
        Exception
            If method specified is not 'leaping' or 'SSA'.
            
        Returns
        -------
        None.
        """
        
        leap_thresh = kwargs.get('leap_threshold',10**2)
        capacity = min(kwargs.get('carrying_capacity',10**18),10**18)
        folder_specified=kwargs.get('new_folder',False)
        self.evo_method = kwargs.get('method','leaping')
        if not (self.evo_method=='leaping' or self.evo_method=='SSA'): 
            raise Exception('method can only be "SSA" or "leaping"')
        
        new_dict = pop_structure.copy()
        self.pop.reset(new_dict,carrying_capacity=capacity,leap_threshold = leap_thresh)
        self.species_list=list(self.pop.pheno_dict.keys())
        self.full_time_course = {}
        self.main_time = 0.
        
        self.folder_name = ''        
        if folder_specified:
            dt=datetime.now()
            dt_str=dt.strftime("%d-%B-%Y(%H.%M.%S)")
            self.folder_name = 'results '+dt_str
            Path(self.folder_name).mkdir(parents=True, exist_ok=True)
            
        
    def evolve(self,*,max_sim_time,recording_interval,birth_rates,death_rates,mut_probs,**kwargs):
        """
        Simulates the evolutionary trajectory of the system (clonal distribution) for specified time while recording the distribution at specified intervals. 
        Note: any time units may be used; however choice of units must be consistent across all parameters, including all demographic rates.

        Parameters
        ----------
        NOTE: All parameters are keyword arguments.
        max_sim_time : float
            Maximum simulation time (or exact simulation time if detection_threshold unspecified; may be shorter if population goes to zero).
        recording_interval : float
            Uime intervals at which the instantaneous clonal distribution will be stored.
        birth_rates : dict
            Birth/division rates (inverse expected time to the division of a cell) specified as {'Name1':birth_rate1,'Name2':birth_rate2,...,'NameN':birth_rateN} with birth_rate1,...,birth_rateN floats; 'Name1',...,'NameN' can be any user-specified type.
        death_rates : dict
            Death rates (inverse expected time to the death of a cell) specified as {'Name1':death_rate1,'Name2':death_rate2,...,'NameN':death_rateN} with death_rate1,...,death_rateN floats; 'Name1',...,'NameN' can be any user-specified type.
        mut_probs : dict
            Mutation probabilities (probability of mutation to phenotype j in a single division of a phenotype i cell) specified as a dictionary of embedded dictionaries {'Name1':{'Name2':prob_mut_1_to_2,...,'NameN':prob_mut_1_to_N},...,'NameN':{'Name1':prob_mut_N_to_1,...,'Name(N-1)':prob_mut_N_to_(N-1)}}.
        to_save: bool, optional
            Whether to save recorded trajectory to file. Default is False.
        detection_threshold: int, optional
            Stops the simulation when the population at or above specified level is detected. Default is no detection threshold (-1). Note that since population size is only checked at certain intervals during the simulation, threshold detection is only approximate.
        quit_at_zero_cells: bool, optional
            Stops the simulation when the total population size is zero. Default is True.
            
        Raises
        ------
            
        Exception
            If the total population is zero (no cells in the system) at the start of simulation interval.

        Returns
        -------
        float
            Total time of this simulation segment.
        pandas dataframe
            Table of population levels of each cell type at each recorded time interval during the simulation.

        """
        
        #if sum(self.pop.get_pops())==0:
        #    raise Exception('Total number of cells is currently zero; cannot simulate evolution.')
        detect_threshold = kwargs.get('detection_threshold',-1)
        quit_at_zero = kwargs.get('quit_at_zero_cells',True)

        #data_format = kwargs.get('data_format','table')
        to_save=kwargs.get('save',False)
        
        init_time = self.main_time
        
        pop_dist={init_time:self.pop.get_pops()}
        is_done = False
        overall_time = 0.
        if self.evo_method == 'leaping':
            while overall_time<max_sim_time and not is_done:
                overall_time,is_done = self.pop.evolve_leaping(overall_time,recording_interval,birth_rates,death_rates,mut_probs,detection_threshold = detect_threshold,quit_at_zero_cells = quit_at_zero) 
                self.main_time = init_time + overall_time
                pop_dist[self.main_time]=list(self.pop.pheno_dict.values())
        elif self.evo_method == 'SSA':
            while overall_time<max_sim_time and not is_done:
                overall_time,is_done = self.pop.evolve_SSA(overall_time,recording_interval,birth_rates,death_rates,mut_probs,detection_threshold = detect_threshold,quit_at_zero_cells = quit_at_zero) 
                self.main_time = init_time + overall_time
                pop_dist[self.main_time]=list(self.pop.pheno_dict.values())
        else: 
            raise Exception('method can only be "SSA" or "leaping"')
        
        final_time = self.main_time
        
        self.full_time_course = {**self.full_time_course,**pop_dist}
        
        name_dict={ind:self.species_list[ind] for ind in range(len(self.species_list))}
        df=pd.DataFrame.from_dict(pop_dist).T.rename(columns=name_dict)
        df.index.rename('Time',inplace=True)
        if to_save:
            if len(self.folder_name)>0:
                df.to_csv(self.folder_name+'/time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
            else:
                df.to_csv('results/time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
        return overall_time, df
    
    def convert_time(self,tc,time_conversion):
        """
        Converts times as user specified on a time course table.

        Parameters
        ----------
        tc: dataframe
            Table of population distribution time course generated by (a) previous call(s) to `Simulator.evolve`.
        time_conversion : str
            Time units to/from, options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks', 'hours_to_months', 'hours_to_years'.

        Raises
        ------
        Exception
            If input tc argument is not of the format generated by a call to `Simulator.evolve`.

        Returns
        -------
        pandas dataframe
            Table of population levels of each cell type at each recorded time interval since simulation initiation after conversion to new times units.

        """
        if not (type(tc)==pd.core.frame.DataFrame and tc.index.name=='Time'):
            raise Exception('Input data format incorrect; refer to documentation')
        new_times=convert_time_list(list(tc.index),time_conversion)
        tc_copy = tc.copy()
        tc_copy.index=new_times
        tc_copy.index.rename('Time',inplace=True)
        return tc_copy
        
    def perform_dilution(self,final_pop,**kwargs):
        """
        Subsamples the population via multinomial sampling for generating a random sample of the current population. This can be used to implement simulation of in-vitro serial dilutions or residual tumor cells following a surgical resection.

        Parameters
        ----------
        final_pop : int
            Desired final total population after subsampling.
        dilution_time: float, optional
            Increment overall time by this interval if dilution is not instantaneous

        Returns
        -------
        None.

        """
        dilution_time=kwargs.get('dilution_time',TIME_EPS)
        pop_to_sample = self.pop.get_pops()
        status = np.random.multinomial(final_pop,(np.array(pop_to_sample)/sum(pop_to_sample)).tolist())
        self.pop.pheno_dict={self.species_list[ind]:status[ind] for ind in range(len(self.species_list))}
        
        self.main_time += dilution_time
        
        new_pop_dist_dict={self.main_time:list(self.pop.pheno_dict.values())}
        self.full_time_course = {**self.full_time_course,**new_pop_dist_dict}
            
    def get_full_time_course(self,**kwargs):
        """
        Returns the full time course of the population distribution from cumulative previous calls to `Simulator.evolve` since the last call to `Simulator.initialize`.

        Parameters
        ----------
        to_save: bool, optional
            Whether to save recorded trajectory to file. Default is False.

        Returns
        -------
        pandas dataframe
            Table of population levels of each cell type at each recorded time interval since simulation initiation.


        """

        to_save=kwargs.get('save',False)
        
        ftc=self.full_time_course
        init_time=list(ftc.keys())[0]
        final_time=list(ftc.keys())[-1]
        
        name_dict={ind:self.species_list[ind] for ind in range(len(self.species_list))}
        df=pd.DataFrame.from_dict(ftc).T.rename(columns=name_dict)
        df.index.rename('Time',inplace=True)
        if to_save:
            if len(self.folder_name)>0:
                df.to_csv(self.folder_name+'/full_time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
            else:
                df.to_csv('results/full_time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
        return df
      
    def pop_total(self):
        """

        Returns
        -------
        int
            Current total population.

        """
        return sum(self.pop.get_pops())
    
    def pop_distribution(self):
        """
        

        Returns
        -------
        dict
            Current population distribution in the same dictionary format as the initial configuration specification.

        """
        return self.pop.pheno_dict.copy()

    def plot_full_time_course_clonal(self,**kwargs):
        """
        Displays and saves a plot of the full time course of the population distribution from cumulative previous calls to `Simulator.evolve` since the last call to `Simulator.initialize`, with the trajectory of each cell type is shown separately and labeled.
        
        Parameters
        ----------
        scale : str, optional
            Plot population levels on a linear or logarithmic scale. Default is linear.
        time_conversion: str, optional
            Generate a plot with time units other than those used in simulation. Options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks','hours_to_months', 'hours_to_years'

        Raises
        ------
        Exception
            If 'scale' is specified as neither 'linear' nor 'log'.
            
        Exception
            If more than 10 cell types are simulated due to visualization capacity.

        Returns
        -------
        None.

        """
        
        scale=kwargs.get('scale','linear')
        if (scale!='linear' and scale!='log'):
            raise Exception('scale can only be "log" or "linear"')
        time_conversion=kwargs.get('time_conversion',None)
        tc=self.get_full_time_course()
        tc_dict=tc.T.to_dict()
        if len(tc.columns)>10:
            raise Exception('Cannot plot more than 10 cell types due to color cycle limitations')
        init_time=list(tc_dict.keys())[0]
        final_time=list(tc_dict.keys())[-1]
        if len(self.folder_name)>0:
            fname=self.folder_name+'/pops_vs_time_full_course_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'
        else:
            fname='results/pops_vs_time_full_course_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'
        plot_subpops_vs_time(tc,scale,time_conversion,fname)
        
    def plot_full_time_course_total(self,**kwargs):
        """
        Displays and saves a plot of the full time course of the total population size from cumulative previous calls to `Simulator.evolve` since the last call to `Simulator.initialize`, with the trajectory of each cell type is shown separately and labeled.
        
        Parameters
        ----------
        scale : str, optional
            Plot population levels on a linear or logarithmic scale. Default is linear.
        time_conversion: str, optional
            Generate a plot with time units other than those used in simulation. Options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks','hours_to_months', 'hours_to_years'

        Raises
        ------
        Exception
            If 'scale' is specified as neither 'linear' nor 'log'.

        Returns
        -------
        None.

        """
        
        scale=kwargs.get('scale','linear')
        if (scale!='linear' and scale!='log'):
            raise Exception('scale can only be "log" or "linear"')
        time_conversion=kwargs.get('time_conversion',None)
        tc=self.get_full_time_course()
        tc_dict=tc.T.to_dict()
        init_time=list(tc_dict.keys())[0]
        final_time=list(tc_dict.keys())[-1]
        
        if len(self.folder_name)>0:
            fname=self.folder_name+'/tot_pop_vs_time_full_course_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'
        else:
            fname='results/tot_pop_vs_time_full_course_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'

        times=list(tc_dict.keys())
        if time_conversion:
            times = convert_time_list(times,time_conversion)
        pop_size=[sum(list(dist.values() ))for dist in tc_dict.values()]
        
        plt.figure(figsize=(8,5))
        plt.plot(times,pop_size)
        if scale=='log':
            plt.yscale('log')
        plt.xlabel('Time')
        plt.ylabel('Number of cells')
        plt.tight_layout()
        plt.savefig(fname)
        plt.show()
       
        
    def plot_any_time_course_clonal(self,tc,**kwargs): #tc must be produced by get_time_course(...)
        """
        Returns and saves a plot of a time course of the population distribution generated from a call to `Simulator.evolve`, with the trajectory of each cell type is shown separately and labeled.
        
        Parameters
        ----------
        tc: dataframe
            Table of population distribution time course generated by a previous call to `Simulator.evolve`.
        scale : str, optional
            Plot population levels on a linear or logarithmic scale. Default is linear.
        time_conversion: str, optional
            Generate a plot with time units other than those used in simulation. Options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks','hours_to_months', 'hours_to_years'

        Raises
        ------
        Exception
            If 'scale' is specified as neither 'linear' nor 'log'.
            
        Exception
            If more than 10 cell types are simulated due to visualization capacity.
            
        Exception
            If input tc argument is not of the format generated by a call to `Simulator.evolve`.

        Returns
        -------
        None.

        """
        scale=kwargs.get('scale','linear')
        if (scale!='linear' and scale!='log'):
            raise Exception('scale can only be "log" or "linear"')
        time_conversion=kwargs.get('time_conversion',None)
        if (type(tc)==pd.core.frame.DataFrame and list(tc.columns)==self.species_list and tc.index.name=='Time'):
            if len(tc.columns)>10:
                raise Exception('Cannot plot more than 10 cell types due to color cycle limitations')
            tc_dict=tc.T.to_dict()
            init_time=list(tc_dict.keys())[0]
            final_time=list(tc_dict.keys())[-1]
            if len(self.folder_name)>0:
                fname=self.folder_name+'/pops_vs_time_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'
            else:
                fname='results/pops_vs_time_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'
            plot_subpops_vs_time(tc,scale,time_conversion,fname)
        else:
            raise Exception('Input data format incorrect; refer to documentation')
            
    def plot_any_time_course_total(self,tc, **kwargs):
        """
        Returns and saves a plot of a time course of the population distribution generated from a call to `Simulator.evolve`.
        
        Parameters
        ----------
        tc: dataframe
            Table of population distribution time course generated by a previous call to `Simulator.evolve`.
        scale : str, optional
            Plot population levels on a linear or logarithmic scale. Default is linear.
        time_conversion: str, optional
            Generate a plot with time units other than those used in simulation. Options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks','hours_to_months', 'hours_to_years'

        Raises
        ------
        Exception
            If 'scale' is specified as neither 'linear' nor 'log'.
            
        Exception
            If input tc argument is not of the format generated by a call to `Simulator.evolve`.

        Returns
        -------
        None.

        """
        
        scale=kwargs.get('scale','linear')
        if (scale!='linear' and scale!='log'):
            raise Exception('scale can only be "log" or "linear"')
        if not (type(tc)==pd.core.frame.DataFrame and list(tc.columns)==self.species_list and tc.index.name=='Time'):
            raise Exception('Input data format incorrect; refer to documentation')
        time_conversion=kwargs.get('time_conversion',None)
        tc_dict=tc.T.to_dict()
        init_time=list(tc_dict.keys())[0]
        final_time=list(tc_dict.keys())[-1]
        
        if len(self.folder_name)>0:
            fname=self.folder_name+'/tot_pop_vs_time_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'
        else:
            fname='results/tot_pop_vs_time_plot_'+str(init_time)+'-'+str(final_time)+'.pdf'

        times=list(tc_dict.keys())
        if time_conversion:
            times = convert_time_list(times,time_conversion)
        pop_size=[sum(list(dist.values() ))for dist in tc_dict.values()]
        
        plt.figure(figsize=(8,5))
        plt.plot(times,pop_size)
        if scale=='log':
            plt.yscale('log')
        plt.xlabel('Time')
        plt.ylabel('Number of cells')
        plt.tight_layout()
        plt.savefig(fname)
        plt.show()
            
        
    def diversity(self,index): #index is diversity index
        """
        Computes the current population diversity according to user-specified diversity index.
        
        Parameters
        ----------
        index: str
            Diversity index. Options are 'shannon', 'simpson', 'gini-simpson', and 'gini'. See functions `shannon`, `simpson`, `gini_simpson`, `gini`.
            
        Raises
        ------
        Exception
            If 'index' is not one of the allowed options.
            
        Returns
        -------
        float
            The specified diversity index of the current population distribution.
        
        """
        cur_pops=self.pop.get_pops()
        probs=np.array(cur_pops)/sum(cur_pops)
        if index=='shannon':
            return shannon(probs)
        elif index=='simpson':
            return simpson(probs)
        elif index=='gini-simpson':
            return gini_simpson(probs)
        elif index=='gini':
            return gini(probs)
        else:
            raise Exception('Diversity index not found; refer to documentation')
            
    def renyi_entropy(self,q): #index is diversity index
        """
        Computes the current population renyi entropy, $$\\frac{1}{1-q}\\ln\\left(\\sum_{i=1}^N f_i^q\\right)$$ for user-specified order \(q\), where the sum is over all species and \(f_i\) represents the frequency (proportion) of cell type \(i\).
        
        Parameters
        ----------
        q: int
             Diversity order
            
        Raises
        ------
        Exception
            If q<=0 or q=1.
            
        Returns
        -------
        float
            The renyi entropy of the current population distribution.
        
        """
        if q<0 or q==1:
            raise Exception('q must be positive number other than unity')
        cur_pops=self.pop.get_pops()
        p=np.array(cur_pops)/sum(cur_pops)
        p=list(filter(lambda pi: pi != 0, p))
        return np.log(np.sum([pi**q for pi in p]))/(1-q)
    
    
    def diversity_full_time_course(self,index,**kwargs):
        """
        Returns the full time course of the specified diversity index from cumulative previous calls to `Simulator.evolve` since the last call to `Simulator.initialize`.

        Parameters
        ----------
        index: str
            Diversity index. Options are 'shannon', 'simpson', 'gini-simpson', and 'gini'. See functions `shannon`, `simpson`, `gini_simpson`, `gini`.
        to_save: bool, optional
            Whether to save recorded trajectory to file. Default is False.

        Raises
        ------
        Exception
            If 'index' is not one of the allowed options.

        Returns
        -------
        pandas dataframe
            Table of specified population diversity index at each recorded time interval since simulation initiation.

        """
        to_save=kwargs.get('save',False)
        ftc=self.full_time_course
        init_time=list(ftc.keys())[0]
        final_time=list(ftc.keys())[-1]
        
        div_dict={}
        for k,v in ftc.items():
            probs=np.array(v)/sum(v)
            if index=='shannon':
                div_dict[k]=shannon(probs)
            elif index=='simpson':
                div_dict[k]=simpson(probs)
            elif index=='gini-simpson':
                div_dict[k]=gini_simpson(probs)
            elif index=='gini':
                div_dict[k]=gini(probs)
            else:
                raise Exception('Diversity index not found; refer to documentation')

        df=pd.DataFrame.from_dict(div_dict,orient='index').rename(columns={0:index})
        df.index.rename('Time',inplace=True)
        if to_save:
            if len(self.folder_name)>0:
                df.to_csv(self.folder_name+'/'+index+'_diversity_full_time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
            else:
                df.to_csv('results/'+index+'_diversity_full_time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
        return df
    
    def diversity_any_time_course(self,tc,index,**kwargs): #FINISH
        """
        Returns a time course of the specified diversity index from a time course generated from a call to `Simulator.evolve`.

        Parameters
        ----------
        tc: dataframe
            Table of population distribution time course generated by a previous call to `Simulator.evolve`.
        index: str
            Diversity index. Options are 'shannon', 'simpson', 'gini-simpson', and 'gini'. See functions `shannon`, `simpson`, `gini_simpson`, `gini`.
        to_save: bool, optional
            Whether to save recorded trajectory to file. Default is False.

        Raises
        ------
        Exception
            If input tc argument is not of the format generated by a call to `Simulator.evolve`.
            
        Exception
            If 'index' is not one of the allowed options.

        Returns
        -------
        pandas dataframe
            Table of specified population diversity index at each recorded time interval since simulation initiation.

        """
        
        to_save=kwargs.get('save',False)
        if not (type(tc)==pd.core.frame.DataFrame and list(tc.columns)==self.species_list and tc.index.name=='Time'):
            raise Exception('Input data format incorrect; refer to documentation')
        tc_dict=tc.T.to_dict() 
        tc_dict={k:list(v.values()) for k,v in tc_dict.items()}
        init_time=list(tc_dict.keys())[0]
        final_time=list(tc_dict.keys())[-1]
        
        div_dict={}
        for k,v in tc_dict.items():
            probs=np.array(v)/sum(v)
            if index=='shannon':
                div_dict[k]=shannon(probs)
            elif index=='simpson':
                div_dict[k]=simpson(probs)
            elif index=='gini-simpson':
                div_dict[k]=gini_simpson(probs)
            elif index=='gini':
                div_dict[k]=gini(probs)
            else:
                raise Exception('Diversity index not found; refer to documentation')

        df=pd.DataFrame.from_dict(div_dict,orient='index').rename(columns={0:index})
        df.index.rename('Time',inplace=True)
        if to_save:
            if len(self.folder_name)>0:
                df.to_csv(self.folder_name+'/'+index+'_diversity_time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
            else:
                df.to_csv('results/'+index+'_diversity_time_course_'+str(init_time)+'-'+str(final_time)+'.csv')
            
        return df
    

class EnsembleSimulator:
    """
    Multi-run (ensemble) simulation of clonal evolution. Uses an initial population distribution and demographic parameters to stochastically generate a time course of population distributions using either the extended-time leaping method (default) or Gillespie's algorithm.

    """ 
    def __init__(self):
          
        Path('ensemble_results').mkdir(parents=True, exist_ok=True)
        self.pop = Population()
        
        self.full_tracking = {}
        """
        Tracks the full evolution of the system (dict) across all runs.
        """
        self.main_time = 0.
        """
        Time since simulation initiation.
        """
        self.folder_name = ''
        self.leap_thresh = 10**2
        self.capacity = 10**18
        self.evo_method='leaping'
        self.detect_threshold = -1
        self.run_num=0

        
    def initialize(self,**kwargs):
        """
        Initializes a simulation ensemble run. Note that since population parameters are specified separately in each run, 
        unlike in the single-run Simulator() initialization, no input parameters are required here upon initialization. 
        However, note that for speed optimization some optional parameters that are specified under `Simulator.evolve`
        are specified here instead upon initialization.
        
        Parameters
        ----------
        leap_threshold: int, optional 
            Subpopulation threshold at which leaping sets in, if in 'leaping' mode. Defaults to 10^2.
        carrying_capacity: int, optional 
            carrying capacity of environment. Defaults to 10^18.
        new_folder: bool, optional
            Save simulation results into a new time-stamped folder instead of default ('results') folder. Default is False.
        method: str, optional
            Specify 'leaping' for extended-time leaping (fast for large populations) or 'SSA' for Gillespie's algorithm (slow for large populations). Default is extended-time leaping.
            
        Raises
        ------
        Exception
            If method specified is not 'leaping' or 'SSA'.
            
        Returns
        -------
        None.

        """
        
        self.leap_thresh = kwargs.get('leap_threshold',10**2)
        self.capacity = min(kwargs.get('carrying_capacity',10**18),10**18)
        folder_specified=kwargs.get('new_folder',False)
        
        self.evo_method = kwargs.get('method','leaping')
        if not (self.evo_method=='leaping' or self.evo_method=='SSA'): 
            raise Exception('method can only be "SSA" or "leaping"')
        
        self.folder_name = ''        
        if folder_specified:
            dt=datetime.now()
            dt_str=dt.strftime("%d-%B-%Y(%H.%M.%S)")
            self.folder_name = 'ensemble_results '+dt_str
            Path(self.folder_name).mkdir(parents=True, exist_ok=True)
            
        self.full_tracking={}
            
    def reset(self,run_num, pop_structure):
        """
        Resets the population configuration for current run to that specified by user.

        Parameters
        ----------
        run_num: int
            This identifies the run in the ensemble for tracking purposes.
        pop_structure: dict
            Initial population distribution specified as {'Name1':Pop1,'Name2':Pop2,...,'NameN':PopN} with Pop1,...,PopN int; 'Name1',...,'NameN' str.

        Returns
        -------
        None.

        """
        new_dict = pop_structure.copy()
        self.pop.reset(new_dict,carrying_capacity=self.capacity,leap_threshold = self.leap_thresh)
        self.species_list=list(self.pop.pheno_dict.keys())
        self.main_time = 0.
        self.run_num = run_num
        self.full_tracking[run_num]={self.main_time:self.pop.get_pops()}
        
    def evolve(self,*,max_sim_time,recording_interval,birth_rates,death_rates,mut_probs,**kwargs):
        """
        Simulates the evolutionary trajectory of the system (clonal distribution) for specified time while recording the distribution at specified intervals and keeping track of recorded population distribution time courses from all runs in the ensemble. 
        Note: any time units may be used; however choice of units must be consistent across all parameters, including all demographic rates.

        Parameters
        ----------
        NOTE: All parameters are keyword arguments.
        max_sim_time : float
            Maximum simulation time (or exact simulation time if detection_threshold unspecified; may be shorter if population goes to zero).
        recording_interval : float
            Uime intervals at which the instantaneous clonal distribution will be stored.
        birth_rates : dict
            Birth/division rates (inverse expected time to the division of a cell) specified as {'Name1':birth_rate1,'Name2':birth_rate2,...,'NameN':birth_rateN} with birth_rate1,...,birth_rateN floats; 'Name1',...,'NameN' can be any user-specified type.
        death_rates : dict
            Death rates (inverse expected time to the death of a cell) specified as {'Name1':death_rate1,'Name2':death_rate2,...,'NameN':death_rateN} with death_rate1,...,death_rateN floats; 'Name1',...,'NameN' can be any user-specified type.
        mut_probs : dict
            Mutation probabilities (probability of mutation to phenotype j in a single division of a phenotype i cell) specified as a dictionary of embedded dictionaries {'Name1':{'Name2':prob_mut_1_to_2,...,'NameN':prob_mut_1_to_N},...,'NameN':{'Name1':prob_mut_N_to_1,...,'Name(N-1)':prob_mut_N_to_(N-1)}}.
        detection_threshold: int, optional
            Stops the simulation when a population at or above specified level is detected. Default is no detection threshold (-1). Note that since population size is only checked at certain intervals during the simulation, threshold detection is only approximate.
        quit_at_zero_cells: bool, optional
            Stops the simulation when the total population size is zero. Default is True.
            
        Raises
        ------
        Exception
            If the total population is zero (no cells in the system) at the start of simulation interval.

        Returns
        -------
        float
            Total time of this simulation segment.

        """
        detect_threshold = kwargs.get('detection_threshold',-1)
        quit_at_zero = kwargs.get('quit_at_zero_cells',True)
        
        #if sum(self.pop.get_pops())==0:
        #    raise Exception('Total number of cells is currently zero; cannot simulate evolution.')
        
        init_time = self.main_time
        
        if self.run_num in self.full_tracking.keys():
            self.full_tracking[self.run_num][init_time]=self.pop.get_pops()
        else:
            self.full_tracking[self.run_num]={init_time:self.pop.get_pops()}
             
        is_done = False
        overall_time = 0.
        if self.evo_method == 'leaping':
            while overall_time<max_sim_time and not is_done:
                overall_time,is_done = self.pop.evolve_leaping(overall_time,recording_interval,birth_rates,death_rates,mut_probs,detection_threshold = detect_threshold,quit_at_zero_cells = quit_at_zero) 
                self.main_time = init_time + overall_time
                self.full_tracking[self.run_num][self.main_time]=self.pop.get_pops()
        elif self.evo_method == 'SSA':
            while overall_time<max_sim_time and not is_done:
                overall_time,is_done = self.pop.evolve_SSA(overall_time,recording_interval,birth_rates,death_rates,mut_probs,detection_threshold = detect_threshold,quit_at_zero_cells = quit_at_zero) 
                self.main_time = init_time + overall_time
                self.full_tracking[self.run_num][self.main_time]=self.pop.get_pops()
        else: 
            raise Exception('method can only be "SSA" or "leaping"')
            
        return overall_time
    
    def get_current_time(self):
        """

        Returns
        -------
        float
            Current simulation time

        """
        return self.main_time
    
    def pop_total(self):
        """

        Returns
        -------
        int
            Current total population.

        """
        return sum(self.pop.get_pops())
    
    def pop_distribution(self):
        """
        

        Returns
        -------
        dict
            Current population distribution in the same dictionary format as the initial configuration specification.

        """
        return self.pop.pheno_dict.copy()
            
    def perform_dilution(self,final_pop,**kwargs):
        """
        Subsamples the population via multinomial sampling for generating a random sample of the current population. This can be used to implement simulation of in-vitro serial dilutions or residual tumor cells following a surgical resection.

        Parameters
        ----------
        final_pop : int
            Desired final total population after subsampling.
        dilution_time: float, optional
            Increment overall time by this interval if dilution is not instantaneous

        Returns
        -------
        None.

        """
        dilution_time=kwargs.get('dilution_time',TIME_EPS)
        pop_to_sample = self.pop.get_pops()
        status = np.random.multinomial(final_pop,(np.array(pop_to_sample)/sum(pop_to_sample)).tolist())
        self.pop.pheno_dict={self.species_list[ind]:status[ind] for ind in range(len(self.species_list))}
        
        self.main_time += dilution_time
        
        if self.run_num in self.full_tracking.keys():
            self.full_tracking[self.run_num][self.main_time]=self.pop.get_pops()
        else:
            self.full_tracking[self.run_num]={self.main_time:self.pop.get_pops()}

        
    def get_full_time_course(self):
        """
        Returns the full time course of population distributions from all runs since last call to `EnsembleSimulator.initialize`.

        Returns
        -------
        dict
            Dictionary of the form {Time 0:[[Pop1,...,PopN],...[Pop1,...,PopN]],..., Time T:[[Pop1,...,PopN],...[Pop1,...,PopN]]},
            where each list [Pop1,...,PopN] is the population distribution for ['Name1',...,'NameN'] (N cell types) at time t for one of the ensemble runs.

        """
        return self.full_tracking
    
        
    def plot_clonal_trajectories(self,**kwargs):
        """
        Displays and saves a plot of the full time courses of all cell types from each ensemble run since the last call to `EnsembleSimulator.initialize`. Distinct cell types are shown with distinct colors and labels.

        Parameters
        ----------
        scale : str, optional
            Plot population levels on a linear or logarithmic scale. Default is linear.
        time_conversion: str, optional
            Generate a plot with time units other than those used in simulation. Options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks','hours_to_months', 'hours_to_years'.
        hline: float,optional
            Draw a horizontal line at this population size

        Raises
        ------
        Exception
            If 'scale' is specified as neither 'linear' nor 'log'.
            
        Exception
            If more than 10 cell types are simulated due to visualization capacity.

        Returns
        -------
        None.

        """
        
        scale=kwargs.get('scale','linear')
        if (scale!='linear' and scale!='log'):
            raise Exception('scale can only be "log" or "linear"')
        if len(self.species_list)>len(sns.color_palette()):
            raise Exception('Too many phenotypes/species to plot; can only plot up to 10')
            
        time_conversion=kwargs.get('time_conversion',None)
        horizontal_line=kwargs.get('hline',None)
        
        color_dict={self.species_list[i]:sns.color_palette()[i] for i in range(len(self.species_list))}
        custom_lines=[]
        for color in color_dict.values():
            custom_lines.append(Line2D([0], [0], color=color, lw=2))  
            
        plt.figure(figsize=(8,5))
        for run,time_course in self.full_tracking.items():
            times=list(time_course.keys())
            if time_conversion:
                times = convert_time_list(times,time_conversion)
            pop_levels=list(time_course.values())
            for species in range(len(self.species_list)):
                plt.plot(times,[dist[species] for dist in pop_levels],color=color_dict[species])
                if scale=='log':
                    plt.yscale('log')
        if horizontal_line:
            plt.axhline(y=horizontal_line,color='gray',linestyle='dashed')             
        plt.legend(custom_lines, list(color_dict.keys()))   
        plt.xlabel('Time')
        plt.ylabel('Number of cells')
        plt.legend(custom_lines, list(color_dict.keys()),bbox_to_anchor=(1.05, 1.0),prop={'size': 16})
        plt.tight_layout()
        if len(self.folder_name)>0:
            fname=self.folder_name+'/clonal_trajectories_plot.pdf'
        else:
            fname='ensemble_results/clonal_trajectories_plot.pdf'
        plt.savefig(fname)
        plt.show()
                
    def plot_total_trajectories(self,**kwargs):
        """
        Displays and saves a plot of the full time courses of the total population level from each ensemble run since the last call to `EnsembleSimulator.initialize`.

        Parameters
        ----------
        scale : str, optional
            Plot population levels on a linear or logarithmic scale. Default is linear.
        time_conversion: str, optional
            Generate a plot with time units other than those used in simulation. Options are 'days_to_weeks', 'days_to_months', 'days_to_years', 'hours_to_days', 'hours_to_weeks','hours_to_months', 'hours_to_years'.
        hline: float,optional
            Draw a horizontal line at this population size
            
        Raises
        ------
        Exception
            If 'scale' is specified as neither 'linear' nor 'log'.

        Returns
        -------
        None.

        """
        scale=kwargs.get('scale','linear')
        if (scale!='linear' and scale!='log'):
            raise Exception('scale can only be "log" or "linear"')
            
        time_conversion=kwargs.get('time_conversion',None)
        horizontal_line=kwargs.get('hline',None)

        plt.figure(figsize=(8,5))
        for run,time_course in self.full_tracking.items():
            times=list(time_course.keys())
            if time_conversion:
                times = convert_time_list(times,time_conversion)
            pop_levels=list(time_course.values())
            tot_pop_levels=[sum(dist) for dist in pop_levels]
            for species in range(len(self.species_list)):
                plt.plot(times,tot_pop_levels,color=sns.color_palette()[0])
                if scale=='log':
                    plt.yscale('log')
        if horizontal_line:
            plt.axhline(y=horizontal_line,color='gray',linestyle='dashed')            
        plt.xlabel('Time')
        plt.ylabel('Number of cells')
        plt.tight_layout()
        if len(self.folder_name)>0:
            fname=self.folder_name+'/total_trajectories_plot.pdf'
        else:
            fname='ensemble_results/total_trajectories_plot.pdf'
        plt.savefig(fname)
        plt.show()
        
    def distributions_final(self):
        """

        Returns
        -------
        dict
            Dictionary of last-time-point distributions from all runs since the last call to `EnsembleSimulator.initialize`.

        """
        final_dists={}
        for run, time_course in self.full_tracking.items():
            final_dists[run]=list(time_course.values())[-1]
        return final_dists
    
    def times_final(self):
        """

        Returns
        -------
        dict
            Dictionary of the last time recorded from each run since the last call to `EnsembleSimulator.initialize`.

        """
        final_times={}
        for run, time_course in self.full_tracking.items():
            final_times[run]=list(time_course.keys())[-1]
        return final_times
        
    def populations_final(self):
        """

        Returns
        -------
        dict
            Dictionary of last-time-point total populations from all runs since the last call to `EnsembleSimulator.initialize`.

        """
        final_pops={}
        for run, time_course in self.full_tracking.items():
            final_pops[run]=sum(list(time_course.values())[-1])
        return final_pops
    
    def proportions_final(self):
        """
        

        Returns
        -------
        dict
            Dictionary of last-time-point cell type proportions from all runs since the last call to `EnsembleSimulator.initialize`..

        """
        dists=self.distributions_final()
        return {run:list(np.array(dist)/sum(dist)) for run,dist in dists.items()}
    
    def distributions_at_time(self,time):
        """
        Parameters
        ----------
        time: float
            One of the time points recorded since last call to `EnsembleSimulator.initialize`.
            
      
        Returns
        -------
        dict
            Dictionary of population distributions from all runs at the the specified recorded time point when available for the run.

        """
        all_dists={}
        for run,time_course in self.full_tracking.items():
            if time in time_course:
                all_dists[run]=time_course[time]

        return all_dists
    
    def populations_at_time(self,time):
        """
        Parameters
        ----------
        time: float
            One of the time points recorded since last call to `EnsembleSimulator.initialize`.
            
      
        Returns
        -------
        dict
            Dictionary of total populations from all runs at the the specified recorded time point when available for the run.

        """
        all_pops={}
        for run,time_course in self.full_tracking.items():
            if time in time_course:
                all_pops[run]=sum(time_course[time])

        return all_pops
    
    
    def proportions_at_time(self,time):
        """
        Parameters
        ----------
        time: float
            One of the time points recorded since last call to `EnsembleSimulator.initialize`.
            
      
        Returns
        -------
        dict
            Dictionary of species proportions from all runs at the the specified recorded time point when available for the run.

        """
        dists=self.distributions_at_time(time)
        return {run:list(np.array(dist)/sum(dist)) for run,dist in dists.items()}
        
    def diversity_final(self,index):
        """
        Computes the user-specified diversity index at tje last recorded time point across all runs.

        Parameters
        ----------
        index: str
            Diversity index. Options are 'shannon', 'simpson', 'gini-simpson', and 'gini'. See functions `shannon`, `simpson`, `gini_simpson`, `gini`.


        Returns
        -------
        list
            List of diversity indices, each corresponding to the diversity at the last recorded time point of each ensemble run.

        """

        dists=self.distributions_final()
        div_list = get_div_dist(list(dists.values()),index)
        return {list(dists.keys())[i]:div_list[i] for i in range(len(dists))}
    
    def diversity_at_time(self,time,index):
        """
        Computes the user-specified diversity index at a specified recorded time point across all runs.

        Parameters
        ----------
        time: float
            One of the time points recorded since last call to `EnsembleSimulator.initialize`.
        index: str
            Diversity index. Options are 'shannon', 'simpson', 'gini-simpson', and 'gini'. See functions `shannon`, `simpson`, `gini_simpson`, `gini`.


        Returns
        -------
        list
            List of diversity indices, each corresponding to the diversity at the specified time point of each ensemble run.

        """

        dists=self.distributions_at_time(time)
        div_list = get_div_dist(list(dists.values()),index)
        return {list(dists.keys())[i]:div_list[i] for i in range(len(dists))}